1. Scope refers to the context within which code is executed. If code is running in a function (a specific context), for example, scope would refer to whatever variables and properties are visible in that function. If we declare a function, and within that function define a variable (x), we have established one context where code is being executed. This context is referred to as the local scope because it is specific to the function. We can attempt to execute that variable (x) outside of the function (a second context called the global scope), but an Uncaught ReferenceError will be returned because (x) is defined only within the context of the function (in the local scope). Outisde of the function we declared, in the global scope, (x) is not defined and therefore is effectively invisible in this second context.

Conversely, had (x) been defined outside of the function (outside of the function scope), (x) would have a global scope and would be available to any and all local scopes. In Javascript, any variable declared outside of a function has a global scope. 

2. Global variables are variables that have a global scope; they are variables declared outside of a function. We wamt to avoid global variables because of the chaos and confusion in a codebase that can result from their use. If we declare a variable outside of a function (a global variable), that variable can still be used inside of a function. The opposite, however, is not true. Using the example described above in (1), we can show how the use of global variables can potentially create multiple conflicts. Global variables use more memory because they don't get sent to the garbage collector. They exist for the lifetime of the program.



In the example above, we defined a variable (x) in a function, so it has a local scope. If we were to then define (x) in the global scope (outside of the function), then (x) would have one value in the global scope and another value in the local scope. If we were to execute the function we created, the value of (x) would be what we declared it to be within the context of the function. However, if we were to then check the value of (x) outside of the function call, it would have the value it was assigned in the global scope (outside of the function). In such a case our codebase would be using variables with the same names but with different return values.             

At the same time, we can also re-assign a global variable's value from inside of a function. Here, the function doesn't create a new variable but it finds the one in the global scope and changes it. In such a case, the local scope would be modifying the global scope, which increases the likelihood of unintended side effects. This can create a problem when a programmer uses global variables in a codebase and, later, contributors to the codebase use code in their function declarations that change the values of the global variables. When the original programmer's code was dependent on the global variables, new code that redefines those variables will break the existing code.

3. The use of Javascript's 'strict mode' addresses the second scenario in (2) above. Strict mode triggers an error when a variable is declared without the let or const keyword. If strict mode is not enabled and a variable is declared without the use of the let or const keyword, Javascript will create that variable in the global scope if it did not exist previously. If it did exist in the global scope previously, Javascript will mutate it. By enforcing the use of let or const, strict mode makes it so variables in the child scope cannot reach outside of their local scope and alter the parent scope. 

4. A side effect in a program is described by the second scenario in (2) and the scenario in (3). It is what happens when a function creates or alters a variable that extends beyond its local scope and consequently changes or creates a variable in its parent scope. Unless a program is specifically designed for the local scope to be able to alter a parent scope,the side effect is considered unintended. Unintended side effects and the use of global variables increase the likelihood of functions in the code becoming indeterminate. A function becomes indeterminate when it relies on a global variable and that variable is mutated by another function. If the global variable is not mutated, the function will return one value. If the global variable is in fact mutated by another function, the function will return another value. In other words, the function can take in the same set of inputs and return different values depending on the state of the global variable. 

Conversely, a function is considered to be determinate when, given the same inputs, it always returns the same value. When a function is determinate and has no side effects (it does not create or mutate variables outside of its local scope) it is called a pure function. 